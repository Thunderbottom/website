---
import { getCollection } from "astro:content";
import PageLayout from "@layouts/PageLayout.astro";
import Container from "@components/Container.astro";
import PhotoCard from "@components/PhotoCard.astro";
import PhotoLightbox from "@components/PhotoLightbox.astro";
import { PHOTOGRAPHY } from "@lib/constants.ts";
import { generateImageStructuredData } from "@lib/photo-utils";

const allPhotos = await getCollection("photography", ({ data }) => {
  return !data.draft;
});

const sortedPhotos = allPhotos.sort(
  (a, b) => new Date(b.data.date).valueOf() - new Date(a.data.date).valueOf(),
);

// Configuration
const PHOTOS_PER_PAGE = 10;
const initialPhotos = sortedPhotos.slice(0, PHOTOS_PER_PAGE);

// Group initial photos by year for display
const photosByYear = initialPhotos.reduce(
  (acc, photo) => {
    const year = new Date(photo.data.date).getFullYear();
    if (!acc[year]) {
      acc[year] = [];
    }
    acc[year].push(photo);
    return acc;
  },
  {} as Record<number, typeof initialPhotos>,
);

const years = Object.keys(photosByYear)
  .map(Number)
  .sort((a, b) => b - a);

const structuredData = generateImageStructuredData(sortedPhotos);
const totalPhotos = sortedPhotos.length;
---

<PageLayout
  title={PHOTOGRAPHY.TITLE}
  description={PHOTOGRAPHY.DESCRIPTION}
  currentPath="/photography/"
  ogType="website"
  keywords="photography, photos, art, creative, visual"
>
  <script
    type="application/ld+json"
    set:html={JSON.stringify(structuredData)}
  />

  <Container>
    <div class="space-y-12">
      <div class="animate">
        <h1 class="font-display text-2xl font-semibold text-text-primary">
          {PHOTOGRAPHY.TITLE}
        </h1>
        <p class="mt-4 text-text-secondary dark:text-text-secondary-dark">
          {PHOTOGRAPHY.DESCRIPTION}
        </p>
      </div>

      <div id="photos-container" class="space-y-12">
        {
          years.map((year) => (
            <section class="animate space-y-6" aria-labelledby={`year-${year}`}>
              <div class="flex justify-end">
                <h2
                  id={`year-${year}`}
                  class="font-display text-xl font-semibold text-text-primary"
                >
                  {year}
                </h2>
              </div>

              <div
                class="space-y-4"
                role="list"
                aria-label={`Photos from ${year}`}
                data-year={year}
              >
                {photosByYear[year].map((photo) => (
                  <div role="listitem">
                    <PhotoCard entry={photo} />
                  </div>
                ))}
              </div>
            </section>
          ))
        }
      </div>

      <!-- Loading indicator -->
      <div
        id="loading-indicator"
        class="animate hidden py-8 text-center"
        aria-live="polite"
        aria-label="Loading more photos"
      >
        <div
          class="inline-flex items-center gap-2 text-text-secondary dark:text-text-secondary-dark"
        >
          <div
            class="h-4 w-4 animate-spin rounded-full border-2 border-text-secondary border-t-transparent"
            aria-hidden="true"
          >
          </div>
          <span>Loading more photos...</span>
        </div>
      </div>

      <!-- Error indicator -->
      <div
        id="error-indicator"
        class="animate hidden py-8 text-center"
        role="alert"
        aria-live="assertive"
      >
        <div class="space-y-4">
          <p class="text-red-600 dark:text-red-400">
            Failed to load more photos. Please check your connection and try
            again.
          </p>
          <button
            id="retry-button"
            class="rounded-lg bg-link px-4 py-2 text-white transition-opacity hover:opacity-80 focus:outline-none focus:ring-2 focus:ring-link focus:ring-offset-2 dark:bg-link-dark"
            aria-label="Retry loading photos"
          >
            Retry
          </button>
        </div>
      </div>

      <!-- End indicator -->
      <div
        id="end-indicator"
        class="animate hidden py-8 text-center"
        aria-live="polite"
      >
        <p class="text-text-secondary dark:text-text-secondary-dark">
          That's all the photos! ðŸ“¸
        </p>
      </div>

      {
        sortedPhotos.length === 0 && (
          <div class="animate py-12 text-center">
            <p class="text-text-secondary">No photos found.</p>
          </div>
        )
      }
    </div>
  </Container>
  <PhotoLightbox />

  <script
    define:vars={{
      photosPerPage: PHOTOS_PER_PAGE,
      totalPhotos: totalPhotos,
    }}
  >
    // Configuration
    const CONFIG = {
      PHOTOS_PER_PAGE: photosPerPage,
      TOTAL_PHOTOS: totalPhotos,
      MAX_RETRIES: 3,
      RETRY_DELAY_BASE: 1000,
      INTERSECTION_MARGIN: "200px",
      API_ENDPOINT: "/api/photos",
    };

    // State management
    let currentPage = 1; // Server-side rendered page 1
    let isLoading = false;
    let hasMorePhotos = CONFIG.TOTAL_PHOTOS > CONFIG.PHOTOS_PER_PAGE;
    let retryCount = 0;

    // DOM elements
    const photosContainer = document.getElementById("photos-container");
    const loadingIndicator = document.getElementById("loading-indicator");
    const errorIndicator = document.getElementById("error-indicator");
    const endIndicator = document.getElementById("end-indicator");
    const retryButton = document.getElementById("retry-button");

    // Validate required elements are present
    if (
      !photosContainer ||
      !loadingIndicator ||
      !errorIndicator ||
      !endIndicator ||
      !retryButton
    ) {
      console.error("[Photography] Required DOM elements not found");
      return;
    }

    /**
     * Initialize intersection observer for infinite scroll
     */
    function initializeIntersectionObserver() {
      const observer = new IntersectionObserver(
        (entries) => {
          const [entry] = entries;
          if (entry.isIntersecting && hasMorePhotos && !isLoading) {
            loadMorePhotos();
          }
        },
        {
          root: null,
          rootMargin: CONFIG.INTERSECTION_MARGIN,
          threshold: 0.1,
        },
      );

      // Create sentinel element
      const sentinel = document.createElement("div");
      sentinel.style.height = "1px";
      sentinel.setAttribute("data-sentinel", "true");
      sentinel.setAttribute("aria-hidden", "true");
      photosContainer.parentNode.insertBefore(sentinel, loadingIndicator);

      observer.observe(sentinel);

      // Cleanup on page navigation
      document.addEventListener("astro:before-swap", () => {
        observer.disconnect();
      });

      return observer;
    }

    /**
     * Load more photos from the API
     */
    async function loadMorePhotos() {
      if (isLoading || !hasMorePhotos) return;

      isLoading = true;
      showLoading();

      try {
        currentPage++;
        const response = await fetchPhotos(currentPage, CONFIG.PHOTOS_PER_PAGE);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();

        if (data.error) {
          throw new Error(data.message || "API returned an error");
        }

        await handleApiResponse(data);

        // Reset retry count on success
        retryCount = 0;
      } catch (error) {
        console.error("[Photography] Failed to load more photos:", error);
        handleLoadError();
        currentPage--; // Reset page counter on error
      } finally {
        isLoading = false;
        hideLoading();
      }
    }

    /**
     * Fetch photos from the API
     */
    async function fetchPhotos(page, limit) {
      const url = new URL(CONFIG.API_ENDPOINT, window.location.origin);
      url.searchParams.set("page", page.toString());
      url.searchParams.set("limit", limit.toString());
      url.searchParams.set("t", Date.now().toString());

      console.log(`[Photography] Fetching page ${page}: ${url.toString()}`);

      return fetch(url.toString(), {
        headers: {
          Accept: "application/json",
          "Cache-Control": "no-cache",
        },
      });
    }

    /**
     * Handle successful API response
     */
    async function handleApiResponse(data) {
      console.log(`[Photography] API Response:`, {
        page: data.page,
        loaded: data.loaded,
        hasMore: data.hasMore,
        total: data.total,
        yearKeys: Object.keys(data.photosByYear || {}),
      });

      // Check if we have photos to render
      if (data.loaded === 0) {
        console.log("[Photography] No photos in this batch");
        hasMorePhotos = false;
        showEndIndicator();
        return;
      }

      // Render new photos by year
      const yearKeys = Object.keys(data.photosByYear)
        .map(Number)
        .sort((a, b) => b - a);

      for (const year of yearKeys) {
        const photos = data.photosByYear[year];
        if (photos && photos.length > 0) {
          await renderPhotosForYear(year, photos);
        }
      }

      // Update state based on API response
      if (!data.hasMore) {
        console.log("[Photography] No more photos after this batch");
        hasMorePhotos = false;
        showEndIndicator();
      }

      // Trigger animations and setup lightbox for new photos
      setTimeout(() => {
        animateNewElements();
        setupPhotoLightbox();
      }, 100);
    }

    /**
     * Render photos for a specific year
     */
    async function renderPhotosForYear(year, photos) {
      let yearSection = photosContainer.querySelector(
        `[data-year="${year}"]`,
      )?.parentElement;

      if (!yearSection) {
        yearSection = createYearSection(year);
        insertYearSectionInOrder(yearSection, year);
      }

      const photosList = yearSection.querySelector(`[data-year="${year}"]`);

      // Render each photo
      for (const photo of photos) {
        const photoElement = createPhotoElement(photo);
        photosList.appendChild(photoElement);
      }
    }

    /**
     * Create a new year section element
     */
    function createYearSection(year) {
      const yearSection = document.createElement("section");
      yearSection.className = "animate space-y-6";
      yearSection.setAttribute("aria-labelledby", `year-${year}`);

      const yearHeader = document.createElement("div");
      yearHeader.className = "flex justify-end";
      yearHeader.innerHTML = `
        <h2 id="year-${year}" class="font-display text-xl font-semibold text-text-primary">
          ${year}
        </h2>
      `;

      const photosList = document.createElement("div");
      photosList.className = "space-y-4";
      photosList.setAttribute("role", "list");
      photosList.setAttribute("aria-label", `Photos from ${year}`);
      photosList.setAttribute("data-year", year);

      yearSection.appendChild(yearHeader);
      yearSection.appendChild(photosList);

      return yearSection;
    }

    /**
     * Insert year section in chronological order
     */
    function insertYearSectionInOrder(yearSection, year) {
      const existingSections = photosContainer.querySelectorAll("section");
      let inserted = false;

      for (const section of existingSections) {
        const existingYearElement = section.querySelector("[data-year]");
        if (existingYearElement) {
          const existingYear = parseInt(
            existingYearElement.getAttribute("data-year"),
          );
          if (year > existingYear) {
            photosContainer.insertBefore(yearSection, section);
            inserted = true;
            break;
          }
        }
      }

      if (!inserted) {
        photosContainer.appendChild(yearSection);
      }
    }

    /**
     * Create a photo element from API data
     */
    function createPhotoElement(photo) {
      const photoDiv = document.createElement("div");
      photoDiv.setAttribute("role", "listitem");
      photoDiv.className = "animate";

      // Create the photo card HTML structure
      photoDiv.innerHTML = `
        <div class="group relative flex flex-col rounded-lg border border-border dark:border-border-dark bg-card dark:bg-card-dark hover:border-text-secondary dark:hover:border-text-secondary-dark hover:bg-gray-50 dark:hover:bg-gray-800 transition-all duration-300 hover:-translate-y-0.5 hover:shadow-md overflow-hidden">
          <div class="relative cursor-pointer" 
               data-photo-trigger
               data-full-image="${photo.images.lightbox.avif.src}"
               data-title="${escapeHtml(photo.data.title)}"
               data-content="${escapeHtml(photo.body || "")}"
               tabindex="0"
               role="button"
               aria-label="View photo: ${escapeHtml(photo.data.title)}">
            <picture>
              <source srcset="${photo.images.thumbnail.avif.src}" type="image/avif" 
                      width="${photo.images.thumbnail.avif.attributes.width}" 
                      height="${photo.images.thumbnail.avif.attributes.height}">
              <source srcset="${photo.images.thumbnail.webp.src}" type="image/webp" 
                      width="${photo.images.thumbnail.webp.attributes.width}" 
                      height="${photo.images.thumbnail.webp.attributes.height}">
              <img src="${photo.images.thumbnail.webp.src}" 
                   alt="${escapeHtml(photo.data.title)}"
                   width="${photo.images.thumbnail.webp.attributes.width}"
                   height="${photo.images.thumbnail.webp.attributes.height}"
                   class="w-full h-auto object-contain transition-transform duration-300"
                   loading="lazy" 
                   decoding="async">
            </picture>
            <div class="absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors duration-300 flex items-center justify-center">
              <div class="opacity-0 group-hover:opacity-100 transition-opacity duration-300 bg-white/90 dark:bg-black/90 rounded-full p-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-text-primary dark:text-text-primary-dark" aria-hidden="true">
                  <line x1="12" y1="5" x2="12" y2="19"></line>
                  <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
              </div>
            </div>
          </div>
          <div class="flex items-start gap-4 p-4">
            <div class="flex-1 min-w-0">
              <div class="flex items-start justify-between gap-4 mb-2">
                <div class="font-display text-lg font-semibold text-text-primary dark:text-text-primary-dark group-hover:text-link dark:group-hover:text-link-dark transition-colors">
                  ${escapeHtml(photo.data.title)}
                </div>
                <time datetime="${new Date(photo.data.date).toISOString()}" class="text-sm text-text-secondary dark:text-text-secondary-dark whitespace-nowrap">
                  ${photo.formattedDate}
                </time>
              </div>
              ${
                photo.exifItems && photo.exifItems.length > 0
                  ? `
                <div class="flex flex-wrap gap-2 text-xs justify-center">
                  ${photo.exifItems
                    .map(
                      (item) => `
                    <span class="px-2 py-1 rounded-md font-mono bg-gray-200 dark:bg-gray-700 text-text-secondary dark:text-text-secondary-dark">
                      ${escapeHtml(item)}
                    </span>
                  `,
                    )
                    .join("")}
                </div>
              `
                  : ""
              }
            </div>
          </div>
        </div>
      `;

      return photoDiv;
    }

    /**
     * Safely escape HTML to prevent XSS
     */
    function escapeHtml(text) {
      if (typeof text !== "string") return "";
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Animate newly added elements
     */
    function animateNewElements() {
      const newElements = photosContainer.querySelectorAll(
        ".animate:not(.show)",
      );
      newElements.forEach((element, index) => {
        setTimeout(() => {
          element.classList.add("show");
        }, index * 50);
      });
    }

    /**
     * UI State Management Functions
     */
    function showLoading() {
      loadingIndicator.classList.remove("hidden");
      hideError();
    }

    function hideLoading() {
      loadingIndicator.classList.add("hidden");
    }

    function showError() {
      errorIndicator.classList.remove("hidden");
      hideLoading();
    }

    function hideError() {
      errorIndicator.classList.add("hidden");
    }

    function showEndIndicator() {
      endIndicator.classList.remove("hidden");
      hideLoading();
      hideError();
    }

    /**
     * Handle load errors with exponential backoff retry
     */
    function handleLoadError() {
      retryCount++;

      if (retryCount <= CONFIG.MAX_RETRIES) {
        console.log(
          `[Photography] Auto-retry ${retryCount}/${CONFIG.MAX_RETRIES}`,
        );

        // Auto-retry with exponential backoff
        const delay = CONFIG.RETRY_DELAY_BASE * Math.pow(2, retryCount - 1);
        setTimeout(() => {
          loadMorePhotos();
        }, delay);
      } else {
        console.error(
          `[Photography] Max retries reached (${CONFIG.MAX_RETRIES})`,
        );
        showError();
      }
    }

    /**
     * Setup photo lightbox for new photos
     */
    function setupPhotoLightbox() {
      // Call the global lightbox setup function if available
      if (window.setupPhotoLightboxTriggers) {
        window.setupPhotoLightboxTriggers();
      }
    }

    /**
     * Initialize the infinite scroll functionality
     */
    function initialize() {
      console.log(
        `[Photography] Initializing with ${CONFIG.TOTAL_PHOTOS} total photos`,
      );

      // Setup retry button
      retryButton.addEventListener("click", () => {
        hideError();
        retryCount = 0; // Reset retry count for manual retry
        loadMorePhotos();
      });

      // Initialize intersection observer
      initializeIntersectionObserver();

      // Setup initial lightbox functionality
      setupPhotoLightbox();

      console.log(`[Photography] Initialization complete`);
    }

    // Initialize when DOM is ready
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initialize);
    } else {
      initialize();
    }

    // Re-initialize after page navigation
    document.addEventListener("astro:after-swap", initialize);
  </script>
</PageLayout>
